
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Cinematic PBR Studio</title>
    <style>
        /* Sketchfab È£éÊ†ºÁöÑÊ∑±ÈÇÉËÉåÊôØ: Êõ¥Âä†ÁªÜËÖªÁöÑÂæÑÂêëÊ∏êÂèò */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at center, #3a3a3a 0%, #1b1b1b 40%, #050505 100%);
        }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #eee; pointer-events: none;
            font-family: 'Segoe UI', sans-serif; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        h1 { margin: 0 0 8px 0; font-size: 15px; color: #4af; letter-spacing: 0.5px; text-transform: uppercase; }
        p { margin: 0; font-size: 11px; color: #aaa; line-height: 1.8; font-weight: 500; }
        .tag { color: #fff; background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; margin-right: 5px; }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0",
    "framer-motion": "https://aistudiocdn.com/framer-motion@^12.23.24",
    "@react-three/fiber": "https://aistudiocdn.com/@react-three/fiber@^9.4.0",
    "@react-three/drei": "https://aistudiocdn.com/@react-three/drei@^10.7.7"
  }
}
</script>
</head>
<body>
    <div id="ui">
        <h1>üßä PBR Viewer Pro</h1>
        <p><span class="tag">NEW</span><b>Dynamic Blob Shadow</b> (Position/Height Tracking)</p>
        <p><span class="tag">AO</span><b>SSAO</b> (Contact Shadows)</p>
        <p><span class="tag">LIGHT</span><b>Hybrid RectArea</b> (Softbox Setup)</p>
        <p style="margin-top: 8px; color: #666;">* Model is auto-rotating to demonstrate shadow tracking</p>
    </div>
    <div id="canvas-container"></div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

// ==========================================
// 1. Ê∏≤ÊüìÊ†∏ÂøÉÈÖçÁΩÆ
// ==========================================
const renderer = new THREE.WebGLRenderer({ 
    powerPreference: "high-performance",
    alpha: true, // ÂÖÅËÆ∏ËÉåÊôØÈÄèÊòéÔºåÈÄèÂá∫ CSS Ê∏êÂèò
    stencil: true,
    depth: true,
    antialias: false // ‰æùËµñÂêéÂ§ÑÁêÜÊàñÈ´òÂàÜÂ±è
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
// renderer.shadowMap.enabled = false; // ÂÖ≥Èó≠ÊòÇË¥µÁöÑÂÆûÊó∂Èò¥ÂΩ±
// renderer.useLegacyLights = false;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
// renderer.outputColorSpace = THREE.SRGBColorSpace;

document.body.appendChild(renderer.domElement);
RectAreaLightUniformsLib.init();

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(3, 2, 5);

// ==========================================
// 2. Âä®ÊÄÅÈò¥ÂΩ±Á≥ªÁªü (Smart Blob Shadow)
// ==========================================
function createSoftShadowTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    
    // ÂàõÂª∫Êõ¥Âä†ÊüîÂíå„ÄÅËá™ÁÑ∂ÁöÑÈùûÁ∫øÊÄßÊ∏êÂèò
    const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
    gradient.addColorStop(0.0, 'rgba(0, 0, 0, 0.8)');  // ‰∏≠ÂøÉÊúÄÈªë
    gradient.addColorStop(0.4, 'rgba(0, 0, 0, 0.3)');  // ‰∏≠Èó¥ËøáÊ∏°
    gradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.05)'); // ËæπÁºòÊûÅÊ∑°
    gradient.addColorStop(1.0, 'rgba(0, 0, 0, 0)');    // ÂÆåÂÖ®ÈÄèÊòé

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    return new THREE.CanvasTexture(canvas);
}

const shadowTexture = createSoftShadowTexture();
const shadowMat = new THREE.MeshBasicMaterial({
    map: shadowTexture,
    transparent: true,
    depthWrite: false, // ÂÖ≥ÈîÆÔºö‰∏çÈÅÆÊå°Ê®°Âûã
    color: 0x000000,
    opacity: 0.6
});
const shadowPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), shadowMat);
shadowPlane.rotation.x = -Math.PI / 2;
shadowPlane.position.y = 0.01; // Á¥ßË¥¥Âú∞Èù¢
// scene.add(shadowPlane);

// Âú∞Èù¢ÁΩëÊ†º (ËßÜËßâÂèÇÁÖß)
// const gridHelper = new THREE.GridHelper(20, 40, 0x666666, 0x333333);
// gridHelper.material.opacity = 0.1;
// gridHelper.material.transparent = true;
// scene.add(gridHelper);

// ==========================================
// 3. ÁÅØÂÖâÁéØÂ¢É (Studio Setup)
// ==========================================
new RGBELoader()
    .setPath('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/')
    .load('royal_esplanade_1k.hdr', function (texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = texture;
        scene.environmentIntensity = 1.0;
    });

// ‰∏ªÂÖâ (Key)
const keyLight = new THREE.RectAreaLight(0xffffff, 3.0, 4, 4);
keyLight.position.set(3, 4, 3);
keyLight.lookAt(0, 0, 0);
scene.add(keyLight);

// ËΩÆÂªìÂÖâ (Rim)
const rimLight = new THREE.RectAreaLight(0x4c8bf5, 5.0, 3, 3);
rimLight.position.set(-3, 2, -4);
rimLight.lookAt(0, 1, 0);
scene.add(rimLight);

// Ë°•ÂÖâ (Fill)
const fillLight = new THREE.RectAreaLight(0xffeedd, 1.5, 5, 5);
fillLight.position.set(-4, 0, 4);
fillLight.lookAt(0, 0, 0);
scene.add(fillLight);

// ==========================================
// 4. ÂêéÂ§ÑÁêÜ (SSAO + ToneMapping)
// ==========================================
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
ssaoPass.kernelRadius = 4;
ssaoPass.minDistance = 0.005;
ssaoPass.maxDistance = 0.1;
composer.addPass(ssaoPass);

const outputPass = new OutputPass();
composer.addPass(outputPass);

// ==========================================
// 5. Ê®°ÂûãÂä†ËΩΩ‰∏éÈÄªËæë
// ==========================================
let activeModel = null; // Â≠òÂÇ®ÂΩìÂâçÊ®°ÂûãÂºïÁî®
let modelBaseY = 0;     // ËÆ∞ÂΩïÊ®°ÂûãËêΩÂú∞Êó∂ÁöÑYÂùêÊ†á
let shadowBaseScale = 1; // ËÆ∞ÂΩïÈò¥ÂΩ±ÁöÑÂü∫Á°ÄÂ§ßÂ∞è

const loader = new GLTFLoader();
const draco = new DRACOLoader();
draco.setDecoderPath('https://unpkg.com/three@0.158.0/examples/jsm/libs/draco/');
loader.setDRACOLoader(draco);

loader.load('./demo/glb/military+character+3d+model_Clone1.glb', (gltf) => {
    const model = gltf.scene;
    
    // Ëá™Âä®ËÆ°ÁÆóÂåÖÂõ¥ÁõíÂπ∂Áº©Êîæ
    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    
    // Áªü‰∏ÄÁº©ÊîæÂà∞ÂêàÈÄÇÂ§ßÂ∞è
    const scale = 3.0 / Math.max(size.x, size.y, size.z);
    model.scale.setScalar(scale);
    
    // Â±Ö‰∏≠
    model.position.x = -center.x * scale;
    model.position.z = -center.z * scale;
    
    // ËÆ°ÁÆóËêΩÂú∞‰ΩçÁΩÆ
    modelBaseY = -box.min.y * scale;
    model.position.y = modelBaseY + 0.2; // ÂàùÂßãÁ®çÂæÆÊÇ¨Á©∫‰∏ÄÁÇπÔºåÂ¢ûÂä†È´òÁ∫ßÊÑü

    // Èò¥ÂΩ±Ëá™ÈÄÇÂ∫îÂ§ßÂ∞èÔºöÊ†πÊçÆÊ®°ÂûãÁöÑÊúÄÂ§ßÂÆΩÂ∫¶Êù•ÂÜ≥ÂÆöÈò¥ÂΩ±Â§öÂ§ß
    shadowBaseScale = Math.max(size.x, size.z) * scale * 1.5;
    shadowPlane.scale.setScalar(shadowBaseScale);

    // ÊùêË¥®‰ºòÂåñ
    const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
    model.traverse(child => {
        if (child.isMesh) {
            child.castShadow = false;
            child.receiveShadow = false;
            if (child.material.map) child.material.map.anisotropy = maxAnisotropy;
            child.material.envMapIntensity = 1.0;
            child.material.flatShading = true;
        }
    });

    scene.add(model);
    activeModel = model; // ËµãÂÄºÁªôÂÖ®Â±ÄÂèòÈáèÔºå‰æõ animate ‰ΩøÁî®

}, undefined, console.error);

// ==========================================
// 6. Âä®Áîª‰∏éËøΩË∏™Âæ™ÁéØ
// ==========================================
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true; // ÂºÄÂêØËá™Âä®ÊóãËΩ¨ÔºåÊºîÁ§∫Âä®ÊÄÅÈò¥ÂΩ±
controls.autoRotateSpeed = 2.0;

const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    // --- Ê†∏ÂøÉÈÄªËæëÔºöÈò¥ÂΩ±ËøΩË∏™ ---
    if (activeModel) {
        // 1. Ê®°ÊãüÊ®°ÂûãÊµÆÂä® (Idle Animation)
        // ËøôÈáåËÆ©Ê®°Âûã‰∏ä‰∏ãÊµÆÂä®ÔºåÊºîÁ§∫Èò¥ÂΩ±ÁöÑÂä®ÊÄÅÂèòÂåñ
        const floatOffset = Math.sin(time * 2) * 0.1;
        activeModel.position.y = (modelBaseY + 0.2) + floatOffset;

        // 2. Èò¥ÂΩ±Ë∑üÈöè X/Z
        shadowPlane.position.x = activeModel.position.x;
        shadowPlane.position.z = activeModel.position.z;

        // 3. Èò¥ÂΩ±Ê†πÊçÆÈ´òÂ∫¶ÂèòÂåñ
        // ËÆ°ÁÆóÊ®°ÂûãÂ∫ïÈÉ®Ë∑ùÁ¶ªÂú∞Èù¢ÁöÑÈ´òÂ∫¶
        const distToFloor = activeModel.position.y - modelBaseY;
        
        // È´òÂ∫¶Ë∂äÈ´òÔºåÈÄèÊòéÂ∫¶Ë∂ä‰Ωé (0.6 -> 0)
        const opacity = THREE.MathUtils.clamp(0.6 - distToFloor * 0.8, 0, 0.8);
        shadowMat.opacity = opacity;

        // È´òÂ∫¶Ë∂äÈ´òÔºåÈò¥ÂΩ±Ë∂äÊâ©Êï£ (Scale ÂèòÂ§ß)
        const scaleFactor = 1 + distToFloor * 1.5;
        shadowPlane.scale.setScalar(shadowBaseScale * scaleFactor);
    }

    controls.update();
    composer.render();
}

window.addEventListener('resize', () => {
    const w = window.innerWidth;
    const h = window.innerHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    composer.setSize(w, h);
    ssaoPass.setSize(w, h);
});

animate();
</script>
</body>
</html>
